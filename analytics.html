<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clan War Analytics</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Arial; max-width: 1100px; margin: 28px auto; padding: 0 16px; color: #e8ebf0; background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.04), transparent 35%), radial-gradient(circle at 80% 0%, rgba(0, 212, 255, 0.08), transparent 25%), #0d1117; }
    h1 { margin: 0 0 10px; }
    .top { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; flex-wrap: wrap; }
    .muted { opacity: 0.8; }
    a { color: #67c7ff; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: linear-gradient(135deg, rgba(0,0,0,0.35), rgba(255,255,255,0.05)); color: inherit; cursor: pointer; box-shadow: 0 8px 18px rgba(0,0,0,0.25); }
    button:hover { border-color: rgba(255,255,255,0.3); background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(0,0,0,0.4)); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; align-items: start; }
    .fullRow { grid-column: 1 / -1; }
    .card { border-radius: 16px; padding: 14px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 20px 60px rgba(0,0,0,0.28); }
    .cardHead { display:flex; justify-content: space-between; align-items:center; margin-bottom: 10px; gap: 10px; }
    .title { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    .toast { font-size: 13px; opacity: 0.8; height: 18px; margin-top: 6px; }
    .actions { display: inline-flex; align-items: center; gap: 8px; }
    .iconBtn { padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.04); color: inherit; cursor: pointer; box-shadow: 0 4px 14px rgba(0,0,0,0.2); font-size: 13px; }
    .iconBtn:hover { border-color: rgba(255,255,255,0.35); }
    .mvpList { list-style: none; padding: 0; margin: 0; display: grid; gap: 8px; }
    .mvpItem { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; border-radius: 12px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); cursor: pointer; transition: border-color 120ms ease, background 120ms ease; }
    .mvpItem:hover { border-color: rgba(255,255,255,0.25); background: rgba(255,255,255,0.05); }
    .copyIcon { opacity: 0.7; font-size: 13px; }
    table { width: 100%; border-collapse: collapse; }
    thead th { text-align: left; padding: 10px 12px; background: linear-gradient(135deg, rgba(0, 255, 170, 0.18), rgba(0, 112, 243, 0.12)); border-bottom: 1px solid rgba(255,255,255,0.12); font-weight: 700; font-size: 14px; letter-spacing: 0.1px; }
    tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    tbody tr:nth-child(even) { background: rgba(255,255,255,0.02); }
    .filtersRow input { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.04); color: inherit; font: inherit; box-sizing: border-box; }
    .sortHeader { cursor: pointer; display: inline-flex; align-items: center; gap: 6px; }
    .sortHeader .arrow { font-size: 12px; opacity: 0.7; }
    .error { margin: 12px 0; padding: 12px 14px; border-radius: 12px; background: rgba(255,0,0,0.12); border: 1px solid rgba(255,0,0,0.25); display:none; }
    .status { margin-left: 4px; }
    .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); font-size: 12px; }
    .pill--urgent { background: rgba(255, 81, 81, 0.18); border: 1px solid rgba(255, 81, 81, 0.45); }
    .pill--A { background: rgba(0, 188, 255, 0.16); border: 1px solid rgba(0, 188, 255, 0.4); }
    .pill--B { background: rgba(255, 206, 86, 0.14); border: 1px solid rgba(255, 206, 86, 0.3); }
    .pill--NEW { background: rgba(153, 102, 255, 0.16); border: 1px solid rgba(153, 102, 255, 0.35); }
    .tableWrap { overflow-x: auto; }
    .toggleWrap { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
    .infoOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 10; }
    .infoPanel { background: #111826; border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 18px; max-width: 720px; width: calc(100% - 32px); box-shadow: 0 20px 60px rgba(0,0,0,0.45); }
    .infoPanel h3 { margin-top: 0; margin-bottom: 10px; }
    .infoPanel p { margin: 0 0 10px; line-height: 1.5; }
    .infoPanel ul { padding-left: 18px; margin: 8px 0 12px; }
    .infoPanel .closeBtn { margin-top: 8px; }
    .cellMain { display: inline-flex; align-items: center; gap: 8px; }
    .reasonText { font-size: 12px; opacity: 0.85; }
    .detailRow td { background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.08); }
    .detailRowInner { padding: 12px; border-radius: 12px; background: #0f1724; border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 12px 32px rgba(0,0,0,0.3); animation: slideDown 200ms ease; }
    .detailHead { display: flex; justify-content: space-between; align-items: center; gap: 12px; margin-bottom: 12px; }
    .detailTitle { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    .detailSubtitle { color: rgba(232,235,240,0.75); margin-top: 4px; font-size: 13px; }
    .detailTable { width: 100%; border-collapse: collapse; border: 1px solid rgba(255,255,255,0.08); border-radius: 10px; overflow: hidden; }
    .detailTable thead th { background: linear-gradient(135deg, rgba(0, 255, 170, 0.16), rgba(0, 112, 243, 0.12)); padding: 10px 12px; text-align: left; font-size: 13px; letter-spacing: 0.1px; }
    .detailTable tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 13px; }
    .detailTable tbody tr:nth-child(even) { background: rgba(255,255,255,0.02); }
    .detailTable .mutedCell { color: rgba(232,235,240,0.6); }
    .detailTable .statCell { border-radius: 8px; }
    .detailTable .scoreCell { font-weight: 700; }
    .clickableCell { cursor: pointer; }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-6px); } to { opacity: 1; transform: translateY(0); } }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="top">
    <h1 style="margin-right: 10px;">Clan War Analytics</h1>
    <a class="muted" href="/index.html">← Terug naar dashboard</a>
    <button id="refresh">Refresh</button>
    <div class="muted status" id="status"></div>
    <div class="muted" id="updated" style="margin-left:auto;"></div>
  </div>
  <div class="error" id="errorBox"></div>

  <div class="grid">
    <div class="card">
      <div class="cardHead">
        <div class="title">Huidig seizoen MVP (Top 10)</div>
        <div class="actions">
          <button class="iconBtn" id="infoCurrent">ℹ️ Info</button>
          <button class="iconBtn" id="copyCurrent">⧉ Kopieer tabel</button>
        </div>
      </div>
      <div class="toast" id="toastCurrent"></div>
      <div id="mvpCurrent">(laden...)</div>
    </div>
    <div class="card">
      <div class="cardHead">
        <div class="title">Vorig seizoen MVP (Top 10)</div>
        <div class="actions">
          <button class="iconBtn" id="infoPrevious">ℹ️ Info</button>
          <button class="iconBtn" id="copyPrevious">⧉ Kopieer tabel</button>
        </div>
      </div>
      <div class="toast" id="toastPrevious"></div>
      <div id="mvpPrevious">(laden...)</div>
    </div>

    <div class="card">
      <div class="cardHead">
        <div class="title">Promotie naar Elder</div>
        <div class="actions">
          <button class="iconBtn" id="infoPromotions">ℹ️ Info</button>
          <button class="iconBtn" id="copyPromotions">⧉ Kopieer lijst</button>
        </div>
      </div>
      <div class="toast" id="toastPromotions"></div>
      <div id="promotionList">(laden...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead toggleWrap">
        <div class="title">Reliability / Ratio Score</div>
        <div class="actions">
          <button class="iconBtn" id="infoRatio">ℹ️ Info</button>
          <button class="iconBtn" id="copyRatio">⧉ Kopieer tabel</button>
          <button id="toggleRatio">Toon alles</button>
        </div>
      </div>
      <div class="toast" id="toastRatio"></div>
      <div class="tableWrap" id="ratioTableWrap"></div>
    </div>

    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Underperformers</div>
        <div class="actions">
          <button class="iconBtn" id="infoUnderperformers">ℹ️ Info</button>
          <button class="iconBtn" id="copyUnderperformers">⧉ Kopieer tabel</button>
        </div>
      </div>
      <div class="toast" id="toastUnderperformers"></div>
      <div class="tableWrap" id="underperformersWrap">(laden...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Watchlist (High performer maar onbetrouwbaar)</div>
        <div class="actions">
          <button class="iconBtn" id="infoWatchlistA">ℹ️ Info</button>
          <button class="iconBtn" id="copyWatchlistA">⧉ Kopieer tabel</button>
        </div>
      </div>
      <div class="toast" id="toastWatchlistA"></div>
      <div class="tableWrap" id="watchlistAWrap">(laden...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Watchlist (Betrouwbaar lage score + Newbies)</div>
        <div class="actions">
          <button class="iconBtn" id="infoWatchlistB">ℹ️ Info</button>
          <button class="iconBtn" id="copyWatchlistB">⧉ Kopieer tabel</button>
        </div>
      </div>
      <div class="toast" id="toastWatchlistB"></div>
      <div class="tableWrap" id="watchlistBWrap">(laden...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead"><div class="title">Contribution table</div><div class="actions"><button class="iconBtn" id="copyContribution">⧉ Kopieer tabel</button></div></div>
      <div class="toast" id="toastContribution"></div>
      <div class="tableWrap" id="contributionWrap">(laden...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead"><div class="title">Decks Used table</div><div class="actions"><button class="iconBtn" id="copyDecks">⧉ Kopieer tabel</button></div></div>
      <div class="toast" id="toastDecks"></div>
      <div class="tableWrap" id="decksWrap">(laden...)</div>
    </div>
  </div>

  <div class="infoOverlay" id="infoOverlay">
    <div class="infoPanel">
      <h3 id="infoTitle"></h3>
      <div id="infoBody"></div>
      <button class="iconBtn closeBtn" id="closeInfo">Sluiten</button>
    </div>
  </div>

<script>
  const el = (id) => document.getElementById(id);

  function showError(msg) {
    const box = el('errorBox');
    box.textContent = msg;
    box.style.display = msg ? 'block' : 'none';
  }

  function copyText(text, toastEl) {
    if (!text) return;
    navigator.clipboard.writeText(text).then(() => {
      if (toastEl) {
        toastEl.textContent = 'Copied!';
        setTimeout(() => (toastEl.textContent = ''), 1200);
      }
    });
  }

  function copyTable(headers, rows, toastEl) {
    const headerLine = headers.join('\t');
    const body = rows.map((r) => r.map((cell) => cell ?? '').join('\t')).join('\n');
    copyText([headerLine, body].filter(Boolean).join('\n'), toastEl);
  }

  function MVPCard(targetId, items, toastEl) {
    const container = document.createElement('ul');
    container.className = 'mvpList';

    if (!items || !items.length) {
      container.innerHTML = '<li class="muted">Geen data</li>';
      el(targetId).innerHTML = '';
      el(targetId).appendChild(container);
      return;
    }

    items.forEach((row, idx) => {
      const li = document.createElement('li');
      li.className = 'mvpItem';
      li.title = 'Klik om te kopiëren';
      li.innerHTML = `<span>${idx + 1}. ${row.player}</span><span class="copyIcon">${row.score} ⧉</span>`;
      li.addEventListener('click', () => copyText(`${row.player} ${row.score}`, toastEl));
      container.appendChild(li);
    });

    const target = el(targetId);
    target.innerHTML = '';
    target.appendChild(container);
  }

  function PromotionList(targetId, items, toastEl) {
    const container = document.createElement('ul');
    container.className = 'mvpList';

    if (!items || !items.length) {
      container.innerHTML = '<li class="muted">Geen promotiekandidaten gevonden</li>';
      el(targetId).innerHTML = '';
      el(targetId).appendChild(container);
      return;
    }

    items.forEach((row) => {
      const li = document.createElement('li');
      li.className = 'mvpItem';
      li.title = 'Klik om te kopiëren';
      li.innerHTML = `
        <div>
          <div><strong>${row.player}</strong> <span class="pill">${row.streak_weeks}w streak</span></div>
          <div class="muted">${row.reason}</div>
        </div>
        <span class="pill">Gem. C: ${row.average_contribution}</span>
      `;
      li.addEventListener('click', () =>
        copyText(
          `${row.player} (${row.streak_weeks}w streak) — ${row.reason} Gem. C: ${row.average_contribution}`,
          toastEl
        )
      );
      container.appendChild(li);
    });

    const target = el(targetId);
    target.innerHTML = '';
    target.appendChild(container);
  }

  function createTableComponent(headers, rows) {
    const getCellValue = (cell) => {
      if (cell && typeof cell === 'object' && !Array.isArray(cell)) {
        return cell.value ?? '';
      }
      return cell ?? '';
    };

    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    const filtersRow = document.createElement('tr');
    filtersRow.className = 'filtersRow';

    let sortIdx = null;
    let sortDir = 1;
    const filters = headers.map(() => '');

    let lastRendered = [];

    function apply() {
      if (openPlayerDetail && openPlayerDetail.table === table) {
        openPlayerDetail.row.remove();
        openPlayerDetail = null;
      }

      let filtered = rows.slice();
      filtered = filtered.filter((row) =>
        row.every((cell, idx) => {
          const needle = (filters[idx] || '').toLowerCase();
          if (!needle) return true;
          return String(getCellValue(cell) || '').toLowerCase().includes(needle);
        })
      );

      if (sortIdx !== null) {
        filtered.sort((a, b) => {
          const av = getCellValue(a[sortIdx]);
          const bv = getCellValue(b[sortIdx]);
          const aNum = parseFloat(av);
          const bNum = parseFloat(bv);
          const bothNum = !Number.isNaN(aNum) && !Number.isNaN(bNum);
          if (bothNum) return (aNum - bNum) * sortDir;
          return String(av).localeCompare(String(bv)) * sortDir;
        });
      }

      const tbody = table.querySelector('tbody');
      tbody.innerHTML = '';
      if (!filtered.length) {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = headers.length;
        td.style.textAlign = 'center';
        td.style.padding = '14px';
        td.textContent = 'Geen resultaten';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      lastRendered = filtered.map((r) => r.map((cell) => getCellValue(cell)));
      filtered.forEach((row) => {
        const tr = document.createElement('tr');
        row.forEach((cell) => {
          const td = document.createElement('td');
          if (cell && typeof cell === 'object' && !Array.isArray(cell)) {
            const main = document.createElement('div');
            main.className = 'cellMain';
            const mainText = document.createElement('span');
            mainText.textContent = cell.value ?? '';
            main.appendChild(mainText);
            if (cell.badge) {
              const badge = document.createElement('span');
              badge.className = `pill ${cell.badgeClass || ''}`.trim();
              badge.textContent = cell.badge;
              main.appendChild(badge);
            }
            td.appendChild(main);
            if (cell.subtitle) {
              const sub = document.createElement('div');
              sub.className = 'reasonText';
              sub.textContent = cell.subtitle;
              td.appendChild(sub);
            }
            if (cell.title) td.title = cell.title;
            if (cell.onClick) {
              td.classList.add('clickableCell');
              td.addEventListener('click', (e) => cell.onClick({ rowEl: tr, tableEl: table }, e));
            }
          } else {
            td.textContent = cell;
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    headers.forEach((h, idx) => {
      const th = document.createElement('th');
      const btn = document.createElement('span');
      btn.className = 'sortHeader';
      const arrow = document.createElement('span');
      arrow.className = 'arrow';
      arrow.textContent = '↕';
      btn.textContent = h || '';
      btn.appendChild(arrow);
      btn.addEventListener('click', () => {
        if (sortIdx === idx) {
          sortDir = -sortDir;
        } else {
          sortIdx = idx;
          sortDir = 1;
        }
        apply();
      });
      th.appendChild(btn);
      headerRow.appendChild(th);

      const filterTh = document.createElement('th');
      const input = document.createElement('input');
      input.placeholder = 'Filter...';
      input.addEventListener('input', (e) => {
        filters[idx] = e.target.value;
        apply();
      });
      filterTh.appendChild(input);
      filtersRow.appendChild(filterTh);
    });

    thead.appendChild(headerRow);
    thead.appendChild(filtersRow);
    table.appendChild(thead);
    table.appendChild(document.createElement('tbody'));

    apply();

    return {
      element: table,
      setRows(newRows) {
        rows = newRows || [];
        apply();
      },
      getHeaders() {
        return headers.slice();
      },
      getVisibleRows() {
        return lastRendered.slice();
      },
    };
  }

  function renderTable(targetId, headers, rows) {
    const comp = createTableComponent(headers, rows);
    const wrap = el(targetId);
    wrap.innerHTML = '';
    wrap.appendChild(comp.element);
    return comp;
  }

  let ratioComponent = null;
  let ratioData = [];
  let underperformersComponent = null;
  let underperformersData = [];
  let watchlistAComponent = null;
  let watchlistAData = [];
  let watchlistBComponent = null;
  let watchlistBData = [];
  let contributionComponent = null;
  let decksComponent = null;
  let analyticsCache = { contribution: { headers: [], rows: [] }, decks: { headers: [], rows: [] } };
  let mvpCurrent = [];
  let mvpPrevious = [];
  let promotionCandidates = [];
  let ratioExpanded = false;
  let openPlayerDetail = null;

  const infoContent = {
    current: {
      title: 'Huidig seizoen MVP (Top 10)',
      body: `
        <p><strong>Berekening</strong></p>
        <ul>
          <li>We nemen alleen weekenden uit het huidige seizoen.</li>
          <li>Een weekend telt als "gespeeld" als de speler Contribution &gt; 0 heeft.</li>
          <li>Voor MVP moet elke gespeelde weekend perfect zijn: Decks Used = 16 (dus 0 gemiste aanvallen).</li>
          <li>Score = som van Contribution over alle gespeelde weekenden in dit seizoen.</li>
          <li>Daarna sorteren we op hoogste score en tonen Top 10.</li>
        </ul>
        <p><strong>Waarom</strong><br />Zo belonen we alleen spelers die én veel bijdragen én geen gaten laten vallen die je niet kunt opvangen.</p>
      `,
    },
    previous: {
      title: 'Vorig seizoen MVP (Top 10)',
      body: `
        <p><strong>Berekening</strong></p>
        <ul>
          <li>We nemen alle weekenden uit het vorige seizoen.</li>
          <li>Een speler is alleen eligible als:</li>
          <li style="margin-left: 16px;">Contribution &gt; 0 in elk weekend (dus elk weekend aanwezig)</li>
          <li style="margin-left: 16px;">én Decks Used = 16 in elk weekend (dus 0 gemiste aanvallen)</li>
          <li>Score = som van Contribution over het hele seizoen.</li>
          <li>Daarna sorteren we op hoogste score en tonen Top 10.</li>
        </ul>
        <p><strong>Waarom</strong><br />MVP is "beste van het seizoen", dus alleen mogelijk met een volledig perfecte aanwezigheid en attack-ratio.</p>
      `,
    },
    promotions: {
      title: 'Promotie naar Elder',
      body: `
        <p><strong>Vereiste</strong></p>
        <ul>
          <li>Huidige rol is <em>Member</em>.</li>
          <li>Minimaal 6 opeenvolgende weekenden met perfecte attacks (Decks Used = 16).</li>
          <li>Gemiddelde Contribution van minstens 2500 per gespeeld weekend.</li>
        </ul>
        <p>We tonen alleen spelers waarvan de huidige streak 6 weken of meer is en de laatste 6 weekenden perfect waren.</p>
      `,
    },
    ratio: {
      title: 'Reliability / Ratio score',
      body: `
        <p><strong>Berekening</strong></p>
        <ul>
          <li>Voor elk weekend in de data kijken we of het weekend "gespeeld" is (Contribution &gt; 0).</li>
          <li>Verwachte decks = 16 per gespeeld weekend.</li>
          <li>Gemiste aanvallen = 16 - Decks Used (alleen voor gespeelde weekenden).</li>
          <li>Strafpunten worden berekend op basis van gemiste aanvallen per weekend volgens jouw regels (zwaarder straffen bij 1–3 miss).</li>
          <li>Reliability score is gebaseerd op totaal gemiste aanvallen + strafpunten en wordt genormaliseerd over het aantal gespeelde weekenden.</li>
        </ul>
        <p><strong>Waarom</strong><br />Dit pakt vooral het "gevaarlijke gedrag" aan: wel meedoen maar te weinig aanvallen doen, waardoor je 2–3 open attacks krijgt die je niet kunt opvangen.</p>
      `,
    },
    underperformers: {
      title: 'Underperformers',
      body: `
        <p><strong>Doel</strong><br />Combineert spelers met lage output én lage betrouwbaarheid. Weeks played is geen eis, nieuwe spelers komen dus direct mee.</p>
        <p><strong>Criteria</strong></p>
        <ul>
          <li>Avg points &lt; 2400</li>
          <li>Reliability % &lt; 95%</li>
        </ul>
        <p><strong>Urgent</strong><br />Toont URGENT badge bij Missed attacks ≥ 8 of Penalty points ≥ 24.</p>
      `,
    },
    watchlistA: {
      title: 'Watchlist A — High performer maar onbetrouwbaar',
      body: `
        <p><strong>Doel</strong><br />Spelers met hoge punten maar reliability onder 95%. Je wilt gedrag verbeteren zonder direct verlies van output.</p>
        <p><strong>Criteria</strong></p>
        <ul>
          <li>Avg points ≥ 2800</li>
          <li>Reliability % &lt; 95%</li>
        </ul>
      `,
    },
    watchlistB: {
      title: 'Watchlist B/C — Betrouwbaar lage score en Newbies',
      body: `
        <p><strong>Watchlist B</strong></p>
        <ul>
          <li>Reliability % ≥ 95%</li>
          <li>Avg points &lt; 2400</li>
          <li>Niet protected (10 weken 16/16 en avg ≥ 2200)</li>
        </ul>
        <p><strong>Watchlist C (Newbies)</strong></p>
        <ul>
          <li>Weeks played &lt; 5</li>
          <li>en Reliability % &lt; 95% of Avg points &lt; 2400</li>
        </ul>
      `,
    },
  };

  function showInfoOverlay(key) {
    const content = infoContent[key];
    if (!content) return;
    el('infoTitle').textContent = content.title;
    el('infoBody').innerHTML = content.body;
    el('infoOverlay').style.display = 'flex';
  }

  const reliabilityHeaders = ['Player', 'Role', 'Weeks played', 'Avg score', 'Missed attacks', 'Reliability %'];

  const normalizeName = (name) => (name || '').replace(/\s+/g, ' ').trim().toLowerCase();

  function parseWeekKeyJs(week) {
    if (!week || typeof week !== 'string') return [-Infinity, -Infinity];
    const [season, idx] = week.split('-').map((part) => parseInt(part.trim(), 10));
    if (Number.isNaN(season) || Number.isNaN(idx)) return [-Infinity, -Infinity];
    return [season, idx];
  }

  function sortWeeksDesc(weeks) {
    return weeks.sort((a, b) => {
      const [sa, ia] = parseWeekKeyJs(a.week);
      const [sb, ib] = parseWeekKeyJs(b.week);
      if (sa !== sb) return sb - sa;
      if (ia !== ib) return ib - ia;
      return (b.week || '').localeCompare(a.week || '');
    });
  }

  function getMissedColor(missed) {
    if (missed === null || missed === undefined) return '';
    if (missed <= 0) return 'rgba(34, 197, 94, 0.25)';
    if (missed === 1) return 'rgba(234, 179, 8, 0.32)';
    if (missed === 2) return 'rgba(249, 115, 22, 0.32)';
    const intensity = Math.min(missed, 8);
    const alpha = 0.28 + (intensity - 3) * 0.04;
    return `rgba(239, 68, 68, ${Math.min(alpha, 0.5)})`;
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function getScoreColor(score) {
    if (score === null || score === undefined || Number.isNaN(score)) return '';
    if (score >= 2800) {
      const clamped = Math.min(score, 3200);
      const t = (clamped - 2800) / 400;
      const light = lerp(42, 30, t);
      return `hsla(140, 65%, ${light}%, 0.32)`;
    }
    if (score >= 2500) {
      const t = (score - 2500) / 300;
      const hue = lerp(60, 140, t);
      const light = lerp(48, 42, t);
      return `hsla(${hue}, 70%, ${light}%, 0.3)`;
    }
    const clamped = Math.max(0, Math.min(score, 2500));
    const t = Math.min((2500 - clamped) / 700, 1);
    const hue = lerp(40, 8, t);
    const light = lerp(48, 32, t);
    return `hsla(${hue}, 75%, ${light}%, 0.32)`;
  }

  function getPlayerWeekData(player) {
    const contrib = analyticsCache.contribution || { headers: [], rows: [] };
    const decks = analyticsCache.decks || { headers: [], rows: [] };
    const contribIdx = (contrib.headers || []).findIndex((h) => (h || '').toLowerCase() === 'c');
    const decksIdx = (decks.headers || []).findIndex((h) => (h || '').toLowerCase() === 'd');
    if (contribIdx === -1 || decksIdx === -1) return [];

    const weekHeaders = (contrib.headers || []).slice(contribIdx + 1);
    const contribRow = (contrib.rows || []).find((r) => normalizeName(r[0]) === normalizeName(player));
    const decksRow = (decks.rows || []).find((r) => normalizeName(r[0]) === normalizeName(player));
    if (!contribRow || !decksRow) return [];

    const weekData = weekHeaders
      .map((wh, idx) => {
        const scoreRaw = contribRow[contribIdx + 1 + idx];
        const scoreNum = scoreRaw === undefined || scoreRaw === '' ? null : Number(scoreRaw);
        const score = Number.isNaN(scoreNum) ? null : scoreNum;
        const attacksRaw = decksRow[decksIdx + 1 + idx];
        const attacksNum = attacksRaw === undefined || attacksRaw === '' ? null : Number(attacksRaw);
        const attacks = Number.isNaN(attacksNum) ? null : attacksNum;
        if (score === null && attacks === null) return null;
        const missed = attacks === null ? null : Math.max(0, 16 - attacks);
        return { week: wh, score, attacks, missed };
      })
      .filter(Boolean);

    return sortWeeksDesc(weekData);
  }

  function clearPlayerDetail() {
    if (openPlayerDetail && openPlayerDetail.row && openPlayerDetail.row.parentNode) {
      openPlayerDetail.row.remove();
    }
    openPlayerDetail = null;
  }

  function renderPlayerDetail(player, reason, tableEl, anchorRow) {
    clearPlayerDetail();

    const weeks = sortWeeksDesc(getPlayerWeekData(player));
    const colCount = tableEl.querySelector('thead tr')?.children.length || anchorRow.children.length || 1;

    const detailTr = document.createElement('tr');
    detailTr.className = 'detailRow';
    detailTr.dataset.player = player;

    const detailTd = document.createElement('td');
    detailTd.colSpan = colCount;

    const inner = document.createElement('div');
    inner.className = 'detailRowInner';

    const head = document.createElement('div');
    head.className = 'detailHead';
    const headLeft = document.createElement('div');
    const title = document.createElement('div');
    title.className = 'detailTitle';
    title.textContent = player || '';
    const subtitle = document.createElement('div');
    subtitle.className = 'detailSubtitle';
    subtitle.textContent = reason || '';
    headLeft.appendChild(title);
    headLeft.appendChild(subtitle);
    const closeBtn = document.createElement('button');
    closeBtn.className = 'iconBtn';
    closeBtn.textContent = 'Sluiten';
    closeBtn.addEventListener('click', clearPlayerDetail);
    head.appendChild(headLeft);
    head.appendChild(closeBtn);
    inner.appendChild(head);

    const tableWrap = document.createElement('div');
    if (!weeks.length) {
      const empty = document.createElement('div');
      empty.className = 'muted';
      empty.textContent = 'Geen weekdata gevonden voor deze speler.';
      tableWrap.appendChild(empty);
    } else {
      const table = document.createElement('table');
      table.className = 'detailTable';
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      ['Week', 'Score', 'Attacks', 'Missed'].forEach((titleText) => {
        const th = document.createElement('th');
        th.textContent = titleText;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      weeks.forEach((row) => {
        const tr = document.createElement('tr');
        const attacksText = row.attacks === null ? '-' : `${row.attacks}/16`;
        const missedText = row.missed === null ? '-' : row.missed;

        const cells = [
          { text: row.week || '-', className: '' },
          { text: row.score === null ? '-' : row.score, className: 'scoreCell', bg: getScoreColor(row.score) },
          { text: attacksText, className: 'statCell' },
          { text: missedText, className: 'statCell', bg: getMissedColor(row.missed) },
        ];

        cells.forEach((cell) => {
          const td = document.createElement('td');
          td.textContent = cell.text;
          if (cell.className) td.classList.add(cell.className);
          if (cell.bg) td.style.background = cell.bg;
          if (cell.text === '-') td.classList.add('mutedCell');
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      tableWrap.appendChild(table);
    }

    inner.appendChild(tableWrap);
    detailTd.appendChild(inner);
    detailTr.appendChild(detailTd);

    anchorRow.parentNode.insertBefore(detailTr, anchorRow.nextSibling);
    openPlayerDetail = { row: detailTr, table: tableEl, player };
  }

  function showPlayerDetail(player, reason, tableEl, anchorRow) {
    if (openPlayerDetail && openPlayerDetail.player === player && openPlayerDetail.table === tableEl) {
      clearPlayerDetail();
      return;
    }
    renderPlayerDetail(player, reason, tableEl, anchorRow);
  }

  function getReliabilityPercent(row) {
    const value = row.reliability_percent ?? row.reliability_score ?? row.reliability;
    if (typeof value === 'number') return Math.round(value * 1000) / 1000;
    const num = Number(value);
    return Number.isNaN(num) ? value : Math.round(num * 1000) / 1000;
  }

  function playerCell(row, reason, badge, badgeClass) {
    return {
      value: row.player,
      subtitle: reason,
      badge,
      badgeClass,
      title: reason,
      onClick: (ctx) => showPlayerDetail(row.player, reason, ctx.tableEl, ctx.rowEl),
    };
  }

  function buildReliabilityRow(row, reason, badge, badgeClass) {
    return [
      playerCell(row, reason, badge, badgeClass),
      row.role || '',
      row.weeks_played,
      row.avg_points,
      row.missed_attacks,
      getReliabilityPercent(row),
    ];
  }

  function hasMeaningfulStats(row) {
    const metrics = [row.weeks_played, row.attacks_done, row.missed_attacks, row.penalty_points, row.avg_points];
    return metrics.some((value) => Number(value) > 0);
  }

  function renderAnalytics(data) {
    mvpCurrent = data.mvp_current || [];
    mvpPrevious = data.mvp_previous || [];
    promotionCandidates = data.promotion_candidates || [];
    MVPCard('mvpCurrent', mvpCurrent, el('toastCurrent'));
    MVPCard('mvpPrevious', mvpPrevious, el('toastPrevious'));
    PromotionList('promotionList', promotionCandidates, el('toastPromotions'));

    const ratioRows = data.ratio_scores || [];
    ratioData = ratioRows.map((row) => [
      row.player,
      row.role || '',
      row.weeks_played,
      row.attacks_done,
      row.missed_attacks,
      row.penalty_points,
      row.avg_points,
      getReliabilityPercent(row),
    ]);

    const ratioHeaders = ['Player', 'Role', 'Weeks played', 'Attacks done', 'Missed attacks', 'Penalty points', 'avg points', 'Reliability %'];
    ratioComponent = renderTable('ratioTableWrap', ratioHeaders, ratioData.slice(0, 10));

    const underperformers = ratioRows.filter(
      (row) => hasMeaningfulStats(row) && Number(row.avg_points) < 2400 && Number(getReliabilityPercent(row)) < 95
    );
    underperformersData = underperformers.map((row) => {
      const urgent = Number(row.missed_attacks) >= 8 || Number(row.penalty_points) >= 24;
      let reason = 'Underperformer: low avg + low reliability';
      if (urgent && Number(row.missed_attacks) >= 8) reason = 'Underperformer (urgent): missed>=8';
      else if (urgent && Number(row.penalty_points) >= 24) reason = 'Underperformer (urgent): penalty>=24';
      return buildReliabilityRow(row, reason, urgent ? 'URGENT' : '', urgent ? 'pill--urgent' : '');
    });
    underperformersComponent = renderTable('underperformersWrap', reliabilityHeaders, underperformersData);

    const watchlistA = ratioRows.filter(
      (row) => hasMeaningfulStats(row) && Number(row.avg_points) >= 2800 && Number(getReliabilityPercent(row)) < 95
    );
    watchlistAData = watchlistA.map((row) => buildReliabilityRow(row, 'Watchlist A: high avg but unreliable', 'A', 'pill--A'));
    watchlistAComponent = renderTable('watchlistAWrap', reliabilityHeaders, watchlistAData);

    const protectedPlayer = (row) => Number(row.weeks_played) === 10 && Number(row.missed_attacks) === 0 && Number(row.avg_points) >= 2200;
    const watchlistB = ratioRows.filter(
      (row) =>
        hasMeaningfulStats(row) &&
        Number(row.weeks_played) >= 5 &&
        Number(getReliabilityPercent(row)) >= 95 &&
        Number(row.avg_points) < 2400 &&
        !protectedPlayer(row)
    );
    const watchlistC = ratioRows.filter(
      (row) =>
        hasMeaningfulStats(row) &&
        Number(row.weeks_played) < 5 &&
        (Number(getReliabilityPercent(row)) < 95 || Number(row.avg_points) < 2400)
    );
    watchlistBData = [
      ...watchlistB.map((row) => buildReliabilityRow(row, 'Watchlist B: reliable but low avg', 'B', 'pill--B')),
      ...watchlistC.map((row) => buildReliabilityRow(row, 'Newbie watch: <5 weeks + risk', 'NEW', 'pill--NEW')),
    ];
    watchlistBComponent = renderTable('watchlistBWrap', reliabilityHeaders, watchlistBData);

    analyticsCache.contribution = data.contribution_table || { headers: [], rows: [] };
    analyticsCache.decks = data.decks_used_table || { headers: [], rows: [] };

    contributionComponent = renderTable('contributionWrap', analyticsCache.contribution.headers, analyticsCache.contribution.rows);

    decksComponent = renderTable('decksWrap', analyticsCache.decks.headers, analyticsCache.decks.rows);
  }

  async function fetchAnalytics() {
    showError('');
    el('status').textContent = 'Laden...';
    try {
      const res = await fetch('/api/analytics');
      const json = await res.json();
      if (!json.ok) throw new Error(json.error || 'Onbekende fout');
      renderAnalytics(json);
      el('status').textContent = '';
      el('updated').textContent = `Laatste refresh: ${new Date().toLocaleString()}`;
    } catch (e) {
      console.error(e);
      showError(e.message);
      el('status').textContent = '';
    }
  }

  el('refresh').addEventListener('click', fetchAnalytics);
  el('toggleRatio').addEventListener('click', () => {
    ratioExpanded = !ratioExpanded;
    el('toggleRatio').textContent = ratioExpanded ? 'Toon minder' : 'Toon alles';
    if (ratioComponent) {
      const slice = ratioExpanded ? ratioData : ratioData.slice(0, 10);
      ratioComponent.setRows(slice);
    }
  });

  el('copyCurrent').addEventListener('click', () => {
    const rows = (mvpCurrent || []).map((row, idx) => [`${idx + 1}`, row.player, row.score]);
    copyTable(['#', 'Player', 'Score'], rows, el('toastCurrent'));
  });

  el('copyPrevious').addEventListener('click', () => {
    const rows = (mvpPrevious || []).map((row, idx) => [`${idx + 1}`, row.player, row.score]);
    copyTable(['#', 'Player', 'Score'], rows, el('toastPrevious'));
  });

  el('copyPromotions').addEventListener('click', () => {
    if (!promotionCandidates || !promotionCandidates.length) return;
    const rows = promotionCandidates.map((row) => [
      `${row.player} (${row.streak_weeks}w streak)`,
      `${row.streak_weeks} weken perfect`,
      `Gem. C: ${row.average_contribution}`,
    ]);
    copyTable(['Player', 'Streak', 'Gemiddelde score'], rows, el('toastPromotions'));
  });

  el('copyRatio').addEventListener('click', () => {
    if (ratioComponent) {
      copyTable(ratioComponent.getHeaders(), ratioComponent.getVisibleRows(), el('toastRatio'));
    }
  });

  el('copyUnderperformers').addEventListener('click', () => {
    if (underperformersComponent) {
      copyTable(underperformersComponent.getHeaders(), underperformersComponent.getVisibleRows(), el('toastUnderperformers'));
    }
  });

  el('copyWatchlistA').addEventListener('click', () => {
    if (watchlistAComponent) {
      copyTable(watchlistAComponent.getHeaders(), watchlistAComponent.getVisibleRows(), el('toastWatchlistA'));
    }
  });

  el('copyWatchlistB').addEventListener('click', () => {
    if (watchlistBComponent) {
      copyTable(watchlistBComponent.getHeaders(), watchlistBComponent.getVisibleRows(), el('toastWatchlistB'));
    }
  });

  el('copyContribution').addEventListener('click', () => {
    if (contributionComponent) {
      copyTable(contributionComponent.getHeaders(), contributionComponent.getVisibleRows(), el('toastContribution'));
    }
  });

  el('copyDecks').addEventListener('click', () => {
    if (decksComponent) {
      copyTable(decksComponent.getHeaders(), decksComponent.getVisibleRows(), el('toastDecks'));
    }
  });

  el('infoCurrent').addEventListener('click', () => showInfoOverlay('current'));
  el('infoPrevious').addEventListener('click', () => showInfoOverlay('previous'));
  el('infoPromotions').addEventListener('click', () => showInfoOverlay('promotions'));
  el('infoRatio').addEventListener('click', () => showInfoOverlay('ratio'));
  el('infoUnderperformers').addEventListener('click', () => showInfoOverlay('underperformers'));
  el('infoWatchlistA').addEventListener('click', () => showInfoOverlay('watchlistA'));
  el('infoWatchlistB').addEventListener('click', () => showInfoOverlay('watchlistB'));
  el('infoOverlay').addEventListener('click', (e) => {
    if (e.target.id === 'infoOverlay') {
      el('infoOverlay').style.display = 'none';
    }
  });
  el('closeInfo').addEventListener('click', () => {
    el('infoOverlay').style.display = 'none';
  });

  fetchAnalytics();
</script>
</body>
</html>
