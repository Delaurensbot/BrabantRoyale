<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clan War Stats</title>
  <style>
    :root {
      --bg: #0c0e16;
      --bg-soft: #141829;
      --card: rgba(22, 26, 40, 0.9);
      --card-border: rgba(177, 92, 255, 0.28);
      --text: #eef2ff;
      --muted: rgba(238, 242, 255, 0.76);
      --purple: #b15cff;
      --purple-soft: rgba(177, 92, 255, 0.24);
      --green: #74ff8d;
      --green-soft: rgba(116, 255, 141, 0.2);
    }
    body { font-family: system-ui, Arial; max-width: 1100px; margin: 28px auto; padding: 0 16px; color: var(--text); background: radial-gradient(circle at 22% 16%, rgba(177, 92, 255, 0.3), transparent 36%), radial-gradient(circle at 76% 0%, rgba(116, 255, 141, 0.24), transparent 28%), linear-gradient(165deg, var(--bg-soft), var(--bg)); }
    h1 { margin: 0 0 10px; }
    .top { display: flex; gap: 12px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
    .muted { color: var(--muted); }
    .clanSwitch { display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0 6px; }
    .clanButton { padding: 8px 12px; border-radius: 10px; border: 1px solid var(--card-border); background: rgba(20, 24, 36, 0.9); cursor: pointer; color: inherit; }
    .clanButton--active { border-color: var(--green); box-shadow: 0 0 0 1px rgba(116, 255, 141, 0.4), 0 10px 24px rgba(0,0,0,0.36); }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid var(--card-border); background: linear-gradient(145deg, rgba(177, 92, 255, 0.22), rgba(116, 255, 141, 0.08)); color: inherit; cursor: pointer; box-shadow: 0 8px 18px rgba(0,0,0,0.25); }
    button:hover { border-color: rgba(116, 255, 141, 0.85); background: linear-gradient(145deg, rgba(177, 92, 255, 0.34), rgba(116, 255, 141, 0.18)); }
    .ctaLink { margin-left: auto; display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; border-radius: 12px; text-decoration: none; font-weight: 700; color: var(--text); background: linear-gradient(135deg, rgba(177, 92, 255, 0.4), rgba(116, 255, 141, 0.15)); border: 1px solid rgba(177, 92, 255, 0.5); box-shadow: 0 10px 28px rgba(0,0,0,0.28); transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease; }
    .ctaLink:hover { border-color: rgba(116, 255, 141, 0.85); transform: translateY(-1px); box-shadow: 0 12px 30px rgba(0,0,0,0.35); }
    .error { margin: 12px 0 18px; padding: 12px 14px; border-radius: 12px; background: rgba(255,0,0,0.12); border: 1px solid rgba(255,0,0,0.25); display:none; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 16px; align-items: start; }
    .fullRow { grid-column: 1 / -1; }
    .card { border-radius: 16px; padding: 14px; background: var(--card); border: 1px solid var(--card-border); box-shadow: 0 20px 60px rgba(0,0,0,0.28); }
    .cardHead { display:flex; justify-content: space-between; align-items:center; margin-bottom: 10px; }
    .title { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    pre { margin: 0; padding: 12px; border-radius: 12px; background: rgba(12, 16, 27, 0.85); border: 1px solid rgba(177, 92, 255, 0.35); min-height: 260px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; cursor: pointer; }
    .toast { font-size: 13px; opacity: 0.8; height: 18px; margin-top: 8px; }
    .overviewTable { width: 100%; border-collapse: collapse; margin-top: 6px; }
    .overviewTable thead th { text-align: left; padding: 10px 12px; background: linear-gradient(135deg, rgba(177, 92, 255, 0.35), rgba(116, 255, 141, 0.2)); border-bottom: 1px solid rgba(177, 92, 255, 0.35); font-weight: 700; font-size: 14px; letter-spacing: 0.1px; }
    .overviewTable tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    .overviewTable tbody tr:nth-child(even) { background: rgba(255,255,255,0.02); }
    .overviewTable .clanName { font-weight: 700; font-size: 15px; }
    .overviewTable .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); font-size: 12px; margin-right: 6px; }
    .overviewTable .sortButton { background: none; border: none; color: inherit; font: inherit; padding: 0; cursor: pointer; }
    .overviewTable .sortButton:hover { text-decoration: underline; }
    .subtle { color: rgba(232,235,240,0.75); font-size: 13px; }
    .empty { padding: 12px; border-radius: 12px; background: rgba(255,255,255,0.03); border: 1px dashed rgba(255,255,255,0.12); text-align: center; }
    .playersTable { width: 100%; border-collapse: collapse; margin-top: 6px; }
    .playersTable thead th { text-align: left; padding: 10px 12px; background: linear-gradient(135deg, rgba(177, 92, 255, 0.35), rgba(116, 255, 141, 0.2)); border-bottom: 1px solid rgba(177, 92, 255, 0.35); font-weight: 700; font-size: 14px; letter-spacing: 0.1px; }
    .playersTable tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    .playersTable tbody tr:nth-child(odd) { background: rgba(255,255,255,0.02); }
    .playersTable .role { font-weight: 700; letter-spacing: 0.2px; }
    .playersTable .badge { display: inline-block; padding: 4px 10px; border-radius: 12px; background: var(--purple-soft); border: 1px solid rgba(177, 92, 255, 0.45); font-size: 12px; margin-left: 6px; }
    .simpleTable { width: 100%; border-collapse: collapse; margin-top: 6px; }
    .simpleTable thead th { text-align: left; padding: 10px 12px; background: linear-gradient(135deg, rgba(177, 92, 255, 0.35), rgba(116, 255, 141, 0.2)); border-bottom: 1px solid rgba(177, 92, 255, 0.35); font-weight: 700; font-size: 14px; letter-spacing: 0.1px; }
    .simpleTable tbody td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.06); font-size: 14px; }
    .simpleTable tbody tr:nth-child(even) { background: rgba(255,255,255,0.02); }
    .finishOutlook { display: grid; gap: 14px; }
    .finishTopStats { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
    .finishStatBox { border-radius: 12px; padding: 12px 14px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); }
    .finishStatLabel { font-size: 13px; text-transform: uppercase; letter-spacing: 0.4px; color: var(--muted); }
    .finishStatValue { margin-top: 4px; font-size: 36px; line-height: 1; font-weight: 800; }
    .finishCards { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 14px; }
    .finishCard { display: flex; align-items: center; gap: 14px; border-radius: 14px; padding: 14px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.08); }
    .finishMetaTitle { color: var(--muted); text-transform: uppercase; letter-spacing: 0.4px; font-size: 12px; font-weight: 700; }
    .finishMetaRank { font-size: 32px; line-height: 1; font-weight: 800; }
    .finishMetaScore { font-size: 28px; line-height: 1.1; font-weight: 700; }
    .ring { --p: 0; --ring-color: var(--purple); width: 90px; height: 90px; border-radius: 50%; position: relative; flex: 0 0 auto; background: conic-gradient(var(--ring-color) calc(var(--p) * 1%), rgba(255,255,255,0.16) 0); }
    .ring::before { content: ""; position: absolute; inset: 11px; border-radius: 50%; background: rgba(12, 16, 27, 0.92); border: 1px solid rgba(255,255,255,0.08); }
    .ringValue { position: absolute; inset: 0; z-index: 1; display: grid; place-items: center; font-size: 31px; font-weight: 800; }
    .ring--projected { --ring-color: #f5b83d; }
    .ring--best { --ring-color: #55d66a; }
    .ring--worst { --ring-color: #ff5c5c; }
    .finishHint { color: var(--muted); font-size: 13px; }
    .hiddenCopy { display: none; }
    @media (max-width: 950px) { .grid { grid-template-columns: 1fr; } pre { min-height: 180px; } }
    @media (max-width: 640px) {
      body { padding: 0 12px; }
      .top { flex-direction: column; align-items: stretch; gap: 10px; }
      .top button, .ctaLink { width: 100%; justify-content: center; text-align: center; }
      h1 { font-size: 26px; }
    }
  </style>
</head>
<body>
  <h1>Clan War Stats</h1>
  <div class="clanSwitch" id="clanSwitch"></div>
  <div class="muted" id="clanLabel"></div>
  <div class="top">
    <div class="muted">Last updated: <span id="updated">-</span></div>
    <button id="refresh">Refresh</button>
    <div class="muted" id="status"></div>
    <a class="ctaLink" id="analyticsLink" href="/analytics.html">Analytics <span aria-hidden="true">â†’</span></a>
    <a class="ctaLink" id="joinLink" href="/join.html">Recent joins <span aria-hidden="true">â†’</span></a>
  </div>

  <div class="error" id="errorBox"></div>

  <div class="grid">
    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Race Overview</div>
      </div>
      <div id="overview" class="empty">(loading...)</div>
    </div>

    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Clan finish outlook</div>
      </div>
      <div id="finishOutlook" class="empty">(loading...)</div>
    </div>

    <div class="card">
      <div class="cardHead">
        <div class="title">Clan avg/projection</div>
        <button data-copy="clanAvg">Copy</button>
      </div>
      <pre id="clanAvg" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="clanAvgToast"></div>
      <div class="muted" id="clanAvgLen"></div>
    </div>

    <div class="card">
      <div class="cardHead">
        <div class="title">Spelers met nog losse aanvallen</div>
        <button data-copy="risk">Copy</button>
      </div>
      <pre id="risk" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="riskToast"></div>
      <div class="muted" id="riskLen"></div>
    </div>

    <div class="card">
      <div class="cardHead">
        <div class="title">Short story</div>
        <button data-copy="story">Copy</button>
      </div>
      <pre id="story" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="storyToast"></div>
      <div class="muted" id="storyLen"></div>
    </div>

    <div class="card">
      <div class="cardHead">
        <div class="title">Battles left (today)</div>
        <button data-copy="battles">Copy</button>
      </div>
      <pre id="battles" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="battlesToast"></div>
      <div class="muted" id="battlesLen"></div>
    </div>

    <div class="card" id="highFameCard" style="display: none;">
      <div class="cardHead">
        <div class="title">Spelers 3000+ ðŸŒŸ</div>
        <button data-copy="highFame">Copy</button>
      </div>
      <pre id="highFame" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="highFameToast"></div>
      <div class="muted" id="highFameLen"></div>
    </div>

    <div class="card" id="day1Card" style="display: none;">
      <div class="cardHead">
        <div class="title">Spelers 800+</div>
        <button data-copy="day1HighFame">Copy</button>
      </div>
      <div id="day1HighFameWrap" class="empty">Alleen zichtbaar op dag 1</div>
      <pre id="day1HighFame" class="hiddenCopy" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="day1HighFameToast"></div>
      <div class="muted" id="day1HighFameLen"></div>
    </div>

    <div class="card" id="day4Card">
      <div class="cardHead">
        <div class="title">Spelers die nog 3k kunnen halen!</div>
        <button data-copy="day4">Copy</button>
      </div>
      <pre id="day4" title="Klik om te kopieren">(loading...)</pre>
      <div class="toast" id="day4Toast"></div>
      <div class="muted" id="day4Len"></div>
    </div>

    <div class="card fullRow">
      <div class="cardHead">
        <div class="title">Players</div>
      </div>
      <div id="players" class="empty">(loading...)</div>
    </div>
  </div>

<script>
  const el = (id) => document.getElementById(id);
  const CLANS = {
    "9YP8UY": { name: "Brabant Royale" },
    "GPCLVLPP": { name: "Brabant Royale 2" },
  };
  const DEFAULT_CLAN = "9YP8UY";

  function updateLength(id, text, limit) {
    const target = el(id + "Len");
    if (!target) return;
    const len = (text || "").length;
    if (limit) {
      target.textContent = len ? `Length: ${len} / ${limit}` : "";
    } else {
      target.textContent = len ? `Length: ${len}` : "";
    }
  }

  function normalizeClanTag(tag) {
    return (tag || "").replace(/[^A-Za-z0-9]/g, "").toUpperCase();
  }

  function clanName(tag) {
    return (CLANS[tag] && CLANS[tag].name) || CLANS[DEFAULT_CLAN].name;
  }

  function updateClanNavLinks() {
    const query = `?clan=${encodeURIComponent(currentClanTag)}`;
    const analyticsLink = el("analyticsLink");
    const joinLink = el("joinLink");
    if (analyticsLink) analyticsLink.href = `/analytics.html${query}`;
    if (joinLink) joinLink.href = `/join.html${query}`;
  }

  function updateClanLabel() {
    const label = el("clanLabel");
    if (label) {
      label.textContent = `Data voor ${clanName(currentClanTag)} (${currentClanTag})`;
    }
  }

  function setClan(tag, skipFetch = false) {
    const normalized = normalizeClanTag(tag);
    currentClanTag = CLANS[normalized] ? normalized : DEFAULT_CLAN;

    document.querySelectorAll(".clanButton").forEach((btn) => {
      if (btn.dataset.clan === currentClanTag) {
        btn.classList.add("clanButton--active");
      } else {
        btn.classList.remove("clanButton--active");
      }
    });

    updateClanLabel();
    updateClanNavLinks();
    if (!skipFetch) {
      fetchData().catch(() => {});
    }
  }

  function renderClanButtons() {
    const switchEl = el("clanSwitch");
    if (!switchEl) return;
    switchEl.innerHTML = "";

    Object.entries(CLANS).forEach(([tag, info]) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "clanButton";
      btn.dataset.clan = tag;
      btn.textContent = `${info.name} (${tag})`;
      btn.addEventListener("click", () => setClan(tag));
      switchEl.appendChild(btn);
    });
  }

  let overviewData = { headCells: [], rows: [] };
  let overviewSortKey = "medals";
  let currentClanTag = DEFAULT_CLAN;

  function parseOverviewValue(value, columnName) {
    const col = (columnName || "").toLowerCase();
    const raw = (value || "").trim();

    if (col.includes("decks")) {
      const m = raw.match(/^(\d+)\s*\/\s*(\d+)/);
      if (!m) return Number.NEGATIVE_INFINITY;
      return parseInt(m[1], 10);
    }

    const n = parseFloat(raw.replace(",", "."));
    if (Number.isNaN(n)) return Number.NEGATIVE_INFINITY;
    return n;
  }

  function sortOverviewRows(key) {
    overviewSortKey = key;
    const idx = overviewData.headCells.findIndex((cell) => cell.toLowerCase().includes(key));
    if (idx === -1) {
      buildOverviewTable(overviewData.headCells, overviewData.rows);
      return;
    }

    const sortedRows = [...overviewData.rows].sort((a, b) => {
      const aVal = parseOverviewValue(a[idx], overviewData.headCells[idx]);
      const bVal = parseOverviewValue(b[idx], overviewData.headCells[idx]);
      if (aVal === bVal) {
        return (a[0] || "").localeCompare(b[0] || "");
      }
      return bVal - aVal;
    });

    buildOverviewTable(overviewData.headCells, sortedRows);
  }

  function isSortableOverviewColumn(label) {
    const l = (label || "").toLowerCase();
    return l.includes("decks") || l.includes("avg") || l.includes("projected") || l.includes("medals");
  }

  function sortKeyForHeader(label) {
    const l = (label || "").toLowerCase();
    if (l.includes("decks")) return "decks";
    if (l.includes("avg")) return "avg";
    if (l.includes("projected")) return "projected";
    if (l.includes("medals")) return "medals";
    return "";
  }

  function buildOverviewTable(headCells, rows) {
    const container = el("overview");
    container.innerHTML = "";
    container.className = "tableWrap";

    const table = document.createElement("table");
    table.className = "overviewTable";

    const thead = document.createElement("thead");
    const headTr = document.createElement("tr");
    headCells.forEach((cell) => {
      const th = document.createElement("th");
      const key = sortKeyForHeader(cell);
      if (isSortableOverviewColumn(cell) && key) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "sortButton";
        btn.textContent = cell || "";
        btn.addEventListener("click", () => sortOverviewRows(key));
        th.appendChild(btn);
      } else {
        th.textContent = cell || "";
      }
      headTr.appendChild(th);
    });
    thead.appendChild(headTr);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    rows.forEach((parts) => {
      const tr = document.createElement("tr");

      parts.forEach((p, idx) => {
        const td = document.createElement("td");
        if (idx === 0) {
          td.className = "clanName";
          td.textContent = p;
        } else if (idx === 1) {
          td.innerHTML = `<span class="pill">${p || "-"}</span>`;
        } else {
          td.textContent = p || "-";
        }
        tr.appendChild(td);
      });

      while (tr.children.length < headCells.length) {
        const td = document.createElement("td");
        td.textContent = "-";
        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    container.appendChild(table);
  }

  function renderOverviewTable(text) {
    const container = el("overview");
    container.innerHTML = "";

    if (!text || !text.trim()) {
      container.className = "empty";
      container.textContent = "(geen data)";
      return;
    }

    const lines = text.split("\n").map(l => l.trimEnd()).filter(Boolean);
    const dataLines = lines.filter(l => l.includes("|") && !/^[-|â€”\s]+$/.test(l));

    if (!dataLines.length) {
      container.className = "empty";
      container.textContent = text;
      return;
    }

    const [header, ...rows] = dataLines;
    const headCells = header.split("|").map(c => c.trim());
    const parsedRows = rows.map(line => line.split("|").map(p => p.trim()));
    overviewData = { headCells, rows: parsedRows };
    overviewSortKey = "medals";

    sortOverviewRows("medals");
  }


  function parseMetricNumber(value, allowDecimal = false) {
    if (value == null) return null;
    const raw = String(value).trim().replace(/\s+/g, "");
    if (!raw) return null;

    if (!allowDecimal) {
      const digitsOnly = raw.replace(/[^\d]/g, "");
      if (!digitsOnly) return null;
      const n = Number(digitsOnly);
      return Number.isFinite(n) ? n : null;
    }

    let normalized = raw;
    const hasComma = normalized.includes(",");
    const hasDot = normalized.includes(".");

    if (hasComma && hasDot) {
      const lastComma = normalized.lastIndexOf(",");
      const lastDot = normalized.lastIndexOf(".");
      if (lastComma > lastDot) {
        normalized = normalized.replace(/\./g, "").replace(",", ".");
      } else {
        normalized = normalized.replace(/,/g, "");
      }
    } else if (hasComma) {
      if (/,[0-9]{1,2}$/.test(normalized)) {
        normalized = normalized.replace(",", ".");
      } else {
        normalized = normalized.replace(/,/g, "");
      }
    } else if (hasDot) {
      if (/\.[0-9]{1,2}$/.test(normalized)) {
        // decimal dot, keep as-is
      } else {
        normalized = normalized.replace(/\./g, "");
      }
    }

    normalized = normalized.replace(/[^\d.-]/g, "");
    const n = Number(normalized);
    return Number.isFinite(n) ? n : null;
  }

  function parseDecksCell(value) {
    const m = (value || "").match(/(\d+)\s*\/\s*(\d+)/);
    if (!m) return { used: null, total: null, remaining: null };
    const used = Number(m[1]);
    const total = Number(m[2]);
    return { used, total, remaining: Math.max(0, total - used) };
  }

  function getOverviewRowsWithMetrics() {
    const head = overviewData.headCells || [];
    const rows = overviewData.rows || [];
    if (!head.length || !rows.length) return [];

    const idxBy = (needle) => head.findIndex((cell) => (cell || "").toLowerCase().includes(needle));
    const idxClan = idxBy("clan");
    const idxDecks = idxBy("decks");
    const idxAvg = idxBy("avg");
    const idxProjected = idxBy("projected");
    const idxMedals = idxBy("medals");

    return rows.map((row) => {
      const decks = parseDecksCell(row[idxDecks] || "");
      return {
        clan: row[idxClan] || "",
        avg: parseMetricNumber(row[idxAvg], true),
        projected: parseMetricNumber(row[idxProjected]),
        medals: parseMetricNumber(row[idxMedals]),
        decksUsed: decks.used,
        decksTotal: decks.total,
        decksRemaining: decks.remaining,
      };
    });
  }

  function parseClanStats(text) {
    const raw = text || "";
    const battles = raw.match(/battles left:\s*([\d.,]+)/i);
    const duels = raw.match(/duels left:\s*([\d.,]+)/i);
    const participants = raw.match(/total players participated:\s*([\d.,]+)/i);
    return {
      battlesLeft: battles ? parseMetricNumber(battles[1]) : null,
      duelsLeft: duels ? parseMetricNumber(duels[1]) : null,
      totalPlayersParticipated: participants ? parseMetricNumber(participants[1]) : null,
    };
  }

  function formatRank(value) {
    const n = Number(value);
    if (!Number.isFinite(n) || n < 1) return "-";
    const mod10 = n % 10;
    const mod100 = n % 100;
    if (mod10 === 1 && mod100 !== 11) return `${n}st`;
    if (mod10 === 2 && mod100 !== 12) return `${n}nd`;
    if (mod10 === 3 && mod100 !== 13) return `${n}rd`;
    return `${n}th`;
  }

  function renderFinishOutlook(data) {
    const container = el("finishOutlook");
    const rows = getOverviewRowsWithMetrics();
    const localeFmt = new Intl.NumberFormat("en-US");

    const rankProgress = (rank) => {
      const safeRank = Number.isFinite(Number(rank)) ? Number(rank) : (rows.length || 5);
      const total = Math.max(1, rows.length || 5);
      return Math.max(8, Math.min(100, ((total - safeRank + 1) / total) * 100));
    };

    const direct = data.finish_outlook || {};
    const directHasAll = [
      direct.battles_left,
      direct.duels_left,
      direct.projected_rank,
      direct.projected_finish,
      direct.best_rank,
      direct.best_finish,
      direct.worst_rank,
      direct.worst_finish,
    ].every((v) => Number.isFinite(Number(v)));

    let battlesLeft;
    let duelsLeft;
    let totalPlayersParticipated;
    let projectedRank;
    let projectedMedals;
    let bestRank;
    let bestPossibleMedals;
    let worstRank;
    let worstPossibleMedals;
    let hintText;

    if (directHasAll) {
      battlesLeft = Number(direct.battles_left);
      duelsLeft = Number(direct.duels_left);
      totalPlayersParticipated = Number.isFinite(Number(data.total_players_participated))
        ? Number(data.total_players_participated)
        : null;
      projectedRank = Number(direct.projected_rank);
      projectedMedals = Number(direct.projected_finish);
      bestRank = Number(direct.best_rank);
      bestPossibleMedals = Number(direct.best_finish);
      worstRank = Number(direct.worst_rank);
      worstPossibleMedals = Number(direct.worst_finish);
      hintText = `Geimporteerd van cwstats.com/clan/${data.clan_tag || currentClanTag}/race.`;
    } else {
      if (!rows.length) {
        container.className = "empty";
        container.textContent = "(geen data)";
        return;
      }

      const ourClanName = (data.clan_name || clanName(currentClanTag) || "").trim().toLowerCase();
      const ours = rows.find((r) => (r.clan || "").trim().toLowerCase() === ourClanName) || rows[0];
      const currentMedals = ours.medals || 0;
      projectedMedals = ours.projected != null
        ? Math.round(ours.projected)
        : Math.round(currentMedals + ((ours.avg || 0) * (ours.decksRemaining || 0)));

      const avgPool = rows.map((r) => r.avg).filter((v) => Number.isFinite(v));
      const minAvg = avgPool.length ? Math.min(...avgPool) : (ours.avg || 0);
      const maxAvg = avgPool.length ? Math.max(...avgPool) : (ours.avg || 0);
      const remainingDecks = ours.decksRemaining || 0;

      worstPossibleMedals = Math.round(currentMedals + (remainingDecks * minAvg));
      bestPossibleMedals = Math.round(currentMedals + (remainingDecks * maxAvg));

      const rankFor = (score) => {
        const better = rows.filter((r) => {
          const baseScore = r.projected != null ? r.projected : r.medals;
          if (baseScore == null) return false;
          return r !== ours && baseScore > score;
        }).length;
        return Math.min(rows.length, better + 1);
      };

      projectedRank = rankFor(projectedMedals);
      bestRank = rankFor(bestPossibleMedals);
      worstRank = rankFor(worstPossibleMedals);

      const stats = parseClanStats(data.clan_stats_text || "");
      battlesLeft = stats.battlesLeft;
      duelsLeft = stats.duelsLeft;
      totalPlayersParticipated = Number.isFinite(Number(data.total_players_participated))
        ? Number(data.total_players_participated)
        : stats.totalPlayersParticipated;
      hintText = "Schatting op basis van huidige score, resterende decks en de huidige avg/deck-range van alle clans.";
    }

    container.className = "finishOutlook";
    container.innerHTML = `
      <div class="finishTopStats">
        <div class="finishStatBox">
          <div class="finishStatLabel">Battles left</div>
          <div class="finishStatValue">${battlesLeft != null ? localeFmt.format(battlesLeft) : "-"}</div>
        </div>
        <div class="finishStatBox">
          <div class="finishStatLabel">Duels left</div>
          <div class="finishStatValue">${duelsLeft != null ? localeFmt.format(duelsLeft) : "-"}</div>
        </div>
        <div class="finishStatBox">
          <div class="finishStatLabel">Total players participated</div>
          <div class="finishStatValue">${totalPlayersParticipated != null ? localeFmt.format(totalPlayersParticipated) : "-"}</div>
        </div>
      </div>

      <div class="finishCards">
        <div class="finishCard">
          <div class="ring ring--projected" style="--p:${rankProgress(projectedRank)}">
            <span class="ringValue">${formatRank(projectedRank)}</span>
          </div>
          <div class="finishMeta">
            <div class="finishMetaTitle">Projected finish</div>
            <div class="finishMetaScore">${projectedMedals != null ? localeFmt.format(projectedMedals) : "-"}</div>
          </div>
        </div>

        <div class="finishCard">
          <div class="ring ring--best" style="--p:${rankProgress(bestRank)}">
            <span class="ringValue">${formatRank(bestRank)}</span>
          </div>
          <div class="finishMeta">
            <div class="finishMetaTitle">Best possible finish</div>
            <div class="finishMetaScore">${bestPossibleMedals != null ? localeFmt.format(bestPossibleMedals) : "-"}</div>
          </div>
        </div>

        <div class="finishCard">
          <div class="ring ring--worst" style="--p:${rankProgress(worstRank)}">
            <span class="ringValue">${formatRank(worstRank)}</span>
          </div>
          <div class="finishMeta">
            <div class="finishMetaTitle">Worst possible finish</div>
            <div class="finishMetaScore">${worstPossibleMedals != null ? localeFmt.format(worstPossibleMedals) : "-"}</div>
          </div>
        </div>
      </div>

      <div class="finishHint">${hintText}</div>
    `;
  }

  function renderPlayersTable(text) {
    const container = el("players");
    container.innerHTML = "";

    if (!text || !text.trim()) {
      container.className = "empty";
      container.textContent = "(geen data)";
      return;
    }

    const lines = text.split("\n").map(l => l.trimEnd()).filter(Boolean);
    const dataLines = lines.filter(l => l.includes("|") && !/^[-|â€”\s]+$/.test(l));

    if (!dataLines.length) {
      container.className = "empty";
      container.textContent = text;
      return;
    }

    container.className = "tableWrap";

    const table = document.createElement("table");
    table.className = "playersTable";

    const [header, ...rows] = dataLines;
    const headCells = header.split("|").map(c => c.trim());
    const thead = document.createElement("thead");
    const headTr = document.createElement("tr");
    headCells.forEach(cell => {
      const th = document.createElement("th");
      th.textContent = cell;
      headTr.appendChild(th);
    });
    thead.appendChild(headTr);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    rows.forEach(line => {
      const parts = line.split("|").map(p => p.trim());
      const tr = document.createElement("tr");

      parts.forEach((p, idx) => {
        const td = document.createElement("td");
        if (idx === 0) {
          td.className = "role";
          td.textContent = p;
        } else if (idx === 1) {
          const [name, badge] = p.split(/\s+-\s+/);
          td.innerHTML = badge ? `${name} <span class="badge">${badge}</span>` : p;
        } else {
          td.textContent = p || "-";
        }
        tr.appendChild(td);
      });

      while (tr.children.length < headCells.length) {
        const td = document.createElement("td");
        td.textContent = "-";
        tr.appendChild(td);
      }

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    container.appendChild(table);
  }

  function renderDay1HighFameTable(players, text) {
    const card = el("day1Card");
    const container = el("day1HighFameWrap");
    const hiddenPre = el("day1HighFame");

    if (!card || !container || !hiddenPre) return;

    const hasPlayers = Array.isArray(players) && players.length > 0;

    if (!hasPlayers || !text) {
      card.style.display = "none";
      container.innerHTML = "";
      hiddenPre.textContent = "";
      return;
    }

    card.style.display = "";
    hiddenPre.textContent = text;

    container.className = "tableWrap";
    container.innerHTML = "";

    const table = document.createElement("table");
    table.className = "simpleTable";

    const thead = document.createElement("thead");
    const headTr = document.createElement("tr");
    ["Speler", "Score"].forEach((label) => {
      const th = document.createElement("th");
      th.textContent = label;
      headTr.appendChild(th);
    });
    thead.appendChild(headTr);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");
    players.forEach((player) => {
      const tr = document.createElement("tr");

      const nameTd = document.createElement("td");
      nameTd.textContent = player.name || "-";
      tr.appendChild(nameTd);

      const fameTd = document.createElement("td");
      fameTd.textContent = player.fame != null ? player.fame : "-";
      tr.appendChild(fameTd);

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);
    container.appendChild(table);
  }

  function formatClanAvgProjection(text) {
    if (!text || !text.trim()) return "(geen data)";

    const lines = text.split("\n").map((line) => line.trim()).filter(Boolean);
    const dataLines = lines.filter((line) => line.includes("|"));

    if (!dataLines.length) return text.trim();

    const rows = dataLines
      .map((line) => line.split("|").map((part) => part.trim()))
      .filter((parts) => parts.length >= 3 && parts[0].toLowerCase() !== "clan name");

    if (!rows.length) return text.trim();

    const sortedRows = [...rows].sort((a, b) => {
      const projectedA = parseFloat(a[2]);
      const projectedB = parseFloat(b[2]);

      const aIsNaN = Number.isNaN(projectedA);
      const bIsNaN = Number.isNaN(projectedB);

      if (aIsNaN && bIsNaN) return 0;
      if (aIsNaN) return 1;
      if (bIsNaN) return -1;

      if (projectedB !== projectedA) return projectedB - projectedA;

      const avgA = parseFloat(a[1]);
      const avgB = parseFloat(b[1]);
      if (Number.isNaN(avgA) || Number.isNaN(avgB)) return 0;
      return avgB - avgA;
    });

    const formattedRows = sortedRows
      .map(([name, avg, projected]) => `${name} ${avg || "-"} --> ${projected || "-"}`);

    return ["Clan avg --> Projected", ...formattedRows].join("\n\n");
  }

  async function copyText(targetId) {
    const map = {
      clanAvg: "clanAvg",
      battles: "battles",
      risk: "risk",
      story: "story",
      highFame: "highFame",
      day1HighFame: "day1HighFame",
      day4: "day4",
    };
    const preId = map[targetId];
    const text = el(preId).textContent || "";
    await navigator.clipboard.writeText(text);

    const toastId = targetId + "Toast";
    el(toastId).textContent = "Copied!";
    setTimeout(() => { el(toastId).textContent = ""; }, 900);
  }

  async function fetchData() {
    el("errorBox").style.display = "none";
    el("status").textContent = `Loading ${clanName(currentClanTag)}...`;

    const url = `/api/cwstats?clan=${encodeURIComponent(currentClanTag)}&t=${Date.now()}`;
    const res = await fetch(url, { cache: "no-store" });

    if (!res.ok) {
      el("status").textContent = "";
      el("errorBox").style.display = "block";
      el("errorBox").textContent = "API error (" + res.status + ")";
      throw new Error("API error " + res.status);
    }

    const data = await res.json();
    if (!data.ok) {
      el("status").textContent = "";
      el("errorBox").style.display = "block";
      el("errorBox").textContent = "API error: " + (data.error || "unknown");
      throw new Error(data.error || "unknown");
    }

    renderOverviewTable(data.race_overview_text || "");
    renderFinishOutlook(data);
    const formattedClanAvg = formatClanAvgProjection(data.clan_avg_projection_text || "");
    el("clanAvg").textContent = formattedClanAvg;
    renderPlayersTable(data.players_text || "");
    el("battles").textContent = data.battles_left_text || "(geen data)";
    el("risk").textContent = data.risk_left_text || "(geen data)";

    const highFameText = (data.high_fame_text || "").trim();
    const highFameCard = el("highFameCard");
    if (highFameCard) {
      if (highFameText) {
        highFameCard.style.display = "";
        el("highFame").textContent = highFameText;
      } else {
        highFameCard.style.display = "none";
        el("highFame").textContent = "";
      }
    }

    const day1Players = Array.isArray(data.day1_high_famers)
      ? data.day1_high_famers
      : [];
    const day1Text = (data.day1_high_fame_text || "").trim();
    renderDay1HighFameTable(day1Players, day1Text);

    const day4Text = (data.day4_last_chance_text || "").trim();
    const day4Card = el("day4Card");
    if (day4Card) {
      if (day4Text) {
        day4Card.style.display = "";
        el("day4").textContent = day4Text;
      } else {
        day4Card.style.display = "none";
        el("day4").textContent = "";
      }
    }

    el("story").textContent = data.short_story_text || "(geen data)";
    updateLength("clanAvg", formattedClanAvg);
    updateLength("battles", data.battles_left_text);
    updateLength("risk", data.risk_left_text);
    updateLength("highFame", highFameText);
    updateLength("day1HighFame", day1Text);
    updateLength("day4", day4Text);
    updateLength("story", data.short_story_text, data.short_story_limit);

    el("updated").textContent = new Date().toLocaleString();
    el("status").textContent = "";
  }

  // Buttons
  el("refresh").addEventListener("click", () => fetchData());

  document.querySelectorAll("button[data-copy]").forEach(btn => {
    btn.addEventListener("click", () => copyText(btn.dataset.copy));
  });

  ["clanAvg","battles","risk","story","highFame","day1HighFame","day4"].forEach(id => {
    el(id).addEventListener("click", () => {
      copyText(id);
    });
  });

  function init() {
    renderClanButtons();
    const params = new URLSearchParams(window.location.search);
    const desired = params.get("clan") || DEFAULT_CLAN;
    setClan(desired, true);
    fetchData().catch(() => {});
  }

  init();
</script>
</body>
</html>
